# -*- coding: utf-8 -*-

# Что есть символы, что есть коды символов и что такое кодировка?

# Каждый символ хранится в памяти компьютера как некий код
# ord(char) - показать код символа
# chr(code) - показать символ, соответствующий коду

print(ord('h'))
print(chr(104))

# вот как хранится строка в памяти
for ch in 'hello':
    print(ord(ch))

codes = [104, 101, 108, 108, 111, ]

# можно её обратно из кодов собрать
out = ''
for code in codes:
    out += chr(code)
print(out)

# а какие вообще символы есть?
for code in range(128):
    print(code, hex(code), chr(code))
# получается таблица символов ASCII  https://ru.wikipedia.org/wiki/ASCII

# то есть каждый символ имеет свой код. В пайтоне символы храняться в кодах unicode
# http://foxtools.ru/Unicode
# Эта таблица стандарт для ВСЕХ симвлов, которое придумало человечество

# Это именно стандарт, а не кодировка — сам по себе Юникод не определяет,
# как символы будут сохранятся на жестком диске или передаваться по сети.
# Он лишь определяет связь между символом и некоторым числом

for code in range(1000, 1200):
    print(code, chr(code))

# но коды символов больших чем байт (256) будут занимать несколько байт.
# Поэтому есть форматы представления текста - как хранить коды юникода.
# например старший байт из двух/трех/етс идет первым или вторым?

# Наиболее распространенным является представление UTF-8 - https://ru.wikipedia.org/wiki/UTF-8
# и в реальности на дисках наши тексты сохраняются в одном из форматов представления

# Как хранить не строки, но сами байты?
# В пайтоне есть тип данных, который позволяет хранить "сырые байты" - bytes

bb = b'\xd1\x84'
print(bb)

# Тип bytes очень похож на str
bb = b'\xd0\xbf\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
print(bb)
print(type(bb))
# по сути это неизменяемые последовательности целых чисел,
# поддерживают те же операции что и str
print(bb[0])
print(bb.count(0xd0))
print(b'he' + b'llo')
# полный список операций - https://goo.gl/7Cznir
# bytes - неизменяемые
# bb[0] = 110

# Пусть есть байты
bb = b'\xd1\x84'
# Это UTF-8 представление русской буквы. Какой?
# давайте разберем (на основе описания формата  - https://goo.gl/Um4xUz)
print(bin(0xd1))
print(bin(0x84))
# 0b11010001
# 0b10000100
# код символа в юникоде занимает 2 байта, значит в первом байте будет 110 сначала, а во втором 10
# значащие биты 10001 и 000100
code = 0b10001000100
print(code)
print(hex(code))
# а это код русской буквы ф в юникоде
print(chr(code))
# элементарно, Ватсон!

# при выводе на терминал есть особенности
# латинские символы ASCII при выводе на терминал отображаются
# как символы, а не коды
bb = b'\x68\xd1\x84'
print(bb)
print(bb.hex())
# (видимо для удобства англоговорящих программистов)

# так же есть изменяемый (mutable) аналог bytes - это bytearray
ba = bytearray(b'hello')
ba[0] = 32  # код пробела
print(ba)
# создаваться bytearray может только через конструктор
print(bytearray())
print(bytearray(16))
print(bytearray(range(16)))
print(bytearray(b'hello'))
print(bytearray('привет', encoding='utf-8'))
print(bytearray('привет'.encode(encoding='utf-8')))


# для преобразования байтов в строку и обратно есть две функции

# строка в байты:
print('привет'.encode(encoding='utf-8'))
print('привет'.encode(encoding='utf-16'))
print('привет'.encode(encoding='cp866'))
# то есть мы хотим ЗАКОДИРОВАТЬ коды уникода в нужное представление

# список всех кодировок - https://docs.python.org/3.5/library/codecs.html#standard-encodings

# байты в строку:
ss = b'\xd0\xbf\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'.decode(encoding='utf-8')
print(ss)
# то есть обратная операция - ДЕКОДИРОВНИЕ из байтов (представления) в строку (unicode)


# а как пайтон узнает что мы в текстах программ пайтон используем определенную кодировку?
# за это отвечает такой вот комментарий в первой или второй строке модуля
# -*- coding: utf-8 -*-
# если такого комментария нет - то предполагается UTF-8
# https://docs.python.org/3/reference/lexical_analysis.html#encoding-declarations


